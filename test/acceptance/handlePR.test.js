import nock from 'nock';
import request from 'supertest';

import StaticmanAPI from '../../source/server';

const staticman = new StaticmanAPI().server;
const supportedApiVersions = [['v1']];

// TODO: Rework this with v3 and gitlab tests once we ditch express-github-webhook

const username = 'johndoe';
const repository = 'foobar';
let basePrResponse;

beforeEach(() => {
  basePrResponse = {
    number: 1,
    title: 'Some PR title',
    body: 'Some PR body text',
    head: {
      ref: 'staticman_123456',
    },
    base: {
      ref: 'master',
    },
    repository: {
      name: repository,
      owner: {
        login: username,
      },
    },
    state: 'merged',
    merged: true,
  };
});

describe.each(supportedApiVersions)('API %s - Webhook endpoint', (version) => {
  it.skip('sends a notification when staticman pull request is merged', async () => {
    const branch = 'staticman_123456';

    const pullScope = _mockFetchPullRequest(basePrResponse);

    const mockBody = {
      parameters: {
        branch,
        repository,
        service: 'github',
        username,
        version,
      },
      fields: {
        name: 'John',
      },
      options: {
        subscribe: 'email',
      },
    };

    expect.assertions(1);

    await request(staticman)
      .post(`/${version}/webhook`)
      .set('X-GitHub-Delivery', 'id')
      .set('X-GitHub-Event', 'pull_request')
      .send({
        repository: {
          owner: {
            login: 'johndoe',
          },
          name: 'foobar',
        },
        number: 1,
        body: `<!--staticman_notification:${mockBody}-->`,
      })
      .expect(200);

    expect(pullScope.isDone()).toBe(true);
  });

  it('ignores pull requests not generated by staticman', async () => {
    const mockResponsePr = {
      ...basePrResponse,
      head: {
        ref: 'some-other-branch',
      },
    };

    const pullScope = _mockFetchPullRequest(mockResponsePr);

    expect.assertions(1);

    await request(staticman)
      .post(`/${version}/webhook`)
      .set('X-GitHub-Delivery', 'id')
      .set('X-GitHub-Event', 'pull_request')
      .send({
        repository: {
          owner: {
            login: 'johndoe',
          },
          name: 'foobar',
        },
        number: 1,
      })
      .expect(200);

    expect(pullScope.isDone()).toBe(true);
  });

  it('ignores staticman pull requests which have not yet been merged', async () => {
    const mockResponsePr = {
      ...basePrResponse,
      state: 'open',
      merged: false,
    };

    const pullScope = _mockFetchPullRequest(mockResponsePr);

    expect.assertions(1);

    await request(staticman)
      .post(`/${version}/webhook`)
      .set('X-GitHub-Delivery', 'id')
      .set('X-GitHub-Event', 'pull_request')
      .send({
        repository: {
          owner: {
            login: 'johndoe',
          },
          name: 'foobar',
        },
        number: 1,
      })
      .expect(200);

    expect(pullScope.isDone()).toBe(true);
  });

  it('ignores non-pull request events', async () => {
    await request(staticman)
      .post(`/${version}/webhook`)
      .set('X-GitHub-Delivery', 'id')
      .set('X-GitHub-Event', 'deployment')
      .send({})
      .expect(200);
  });
});

function _mockFetchPullRequest(responsePrBody) {
  return nock(/api\.github\.com/, {
    reqheaders: {
      authorization: 'token '.concat('1q2w3e4r'),
    },
  })
    .get(
      `/repos/${responsePrBody.repository.owner.login}/${responsePrBody.repository.name}/pulls/${responsePrBody.number}`
    )
    .reply(200, responsePrBody);
}

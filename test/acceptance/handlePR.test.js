import nock from 'nock';
import request from 'supertest';

import StaticmanAPI from '../../source/server';

const staticman = new StaticmanAPI().server;
const supportedApiVersions = [['v1']];

// TODO: Rework this with v3 and gitlab tests once we ditch express-github-webhook

const username = 'johndoe';
const repository = 'foobar';
const branch = 'staticman_123456';

let basePrBody;
let basePrResponse;

beforeEach(() => {
  basePrBody = {
    parameters: {
      branch,
      repository,
      service: 'github',
      username,
      version: '1',
    },
    fields: {
      name: 'John',
    },
    options: {
      subscribe: 'email',
    },
  };
  basePrResponse = {
    number: 1,
    title: 'Some PR title',
    body: `<!--staticman_notification:${JSON.stringify(basePrBody)}-->`,
    head: {
      ref: branch,
    },
    base: {
      ref: 'master',
    },
    repository: {
      name: repository,
      owner: {
        login: username,
      },
    },
    state: 'merged',
    merged: true,
  };
});

describe.each(supportedApiVersions)('API %s - Webhook endpoint', (version) => {
  it('sends a notification when staticman pull request is merged', async () => {
    basePrBody.parameters.version = version.charAt(1);

    const mockPrResponse = {
      ...basePrResponse,
      body: `<!--staticman_notification:${JSON.stringify(basePrBody)}-->`,
    };

    const pullScope = _mockFetchPullRequest(mockPrResponse);
    const deleteScope = _mockDeleteBranch(branch);

    expect.assertions(2);

    await request(staticman)
      .post(`/${version}/webhook`)
      .set('X-GitHub-Delivery', 'id')
      .set('X-GitHub-Event', 'pull_request')
      .send({
        repository: {
          owner: {
            login: 'johndoe',
          },
          name: 'foobar',
        },
        number: 1,
      })
      .expect(200);

    expect(pullScope.isDone()).toBe(true);
    expect(deleteScope.isDone()).toBe(true);
  });

  it('ignores pull requests not generated by staticman', async () => {
    const mockResponsePr = {
      ...basePrResponse,
      head: {
        ref: 'some-other-branch',
      },
    };

    const pullScope = _mockFetchPullRequest(mockResponsePr);

    expect.assertions(1);

    await request(staticman)
      .post(`/${version}/webhook`)
      .set('X-GitHub-Delivery', 'id')
      .set('X-GitHub-Event', 'pull_request')
      .send({
        repository: {
          owner: {
            login: 'johndoe',
          },
          name: 'foobar',
        },
        number: 1,
      })
      .expect(200);

    expect(pullScope.isDone()).toBe(true);
  });

  it('ignores staticman pull requests which have not yet been merged', async () => {
    const mockResponsePr = {
      ...basePrResponse,
      state: 'open',
      merged: false,
    };

    const pullScope = _mockFetchPullRequest(mockResponsePr);

    expect.assertions(1);

    await request(staticman)
      .post(`/${version}/webhook`)
      .set('X-GitHub-Delivery', 'id')
      .set('X-GitHub-Event', 'pull_request')
      .send({
        repository: {
          owner: {
            login: 'johndoe',
          },
          name: 'foobar',
        },
        number: 1,
      })
      .expect(200);

    expect(pullScope.isDone()).toBe(true);
  });

  it('ignores non-pull request events', async () => {
    await request(staticman)
      .post(`/${version}/webhook`)
      .set('X-GitHub-Delivery', 'id')
      .set('X-GitHub-Event', 'deployment')
      .send({})
      .expect(200);
  });
});

function _mockFetchPullRequest(responsePrBody) {
  return nock(/api\.github\.com/, {
    reqheaders: {
      authorization: 'token '.concat('1q2w3e4r'),
    },
  })
    .get(
      `/repos/${responsePrBody.repository.owner.login}/${responsePrBody.repository.name}/pulls/${responsePrBody.number}`
    )
    .reply(200, responsePrBody);
}

function _mockDeleteBranch(branchName) {
  const endpoint = `/repos/${username}/${repository}/git/refs/heads%2F${encodeURI(branchName)}`;

  return nock(/api\.github\.com/, {
    reqheaders: {
      authorization: 'token '.concat('1q2w3e4r'),
    },
  })
    .delete(endpoint)
    .reply(204);
}

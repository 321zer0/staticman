import nock from 'nock';
import request from 'supertest';

import * as GitHubMocks from '../helpers/githubApiMocks';
import * as sampleData from '../helpers/sampleData';
import StaticmanAPI from '../../source/server';

const staticman = new StaticmanAPI().server;
const supportedApiVersions = [['v1']];

// TODO: Rework this with v3 and gitlab tests once we ditch express-github-webhook

const username = 'johndoe';
const repository = 'foobar';
const branch = 'staticman_123456';

let basePrBody;
let basePrResponse;

beforeEach(() => {
  basePrBody = {
    parameters: {
      branch,
      repository,
      service: 'github',
      username,
      version: '1',
    },
    fields: {
      name: 'John',
    },
    options: {
      subscribe: 'email',
    },
  };
  basePrResponse = {
    number: 1,
    title: 'Some PR title',
    body: `<!--staticman_notification:${JSON.stringify(basePrBody)}-->`,
    head: {
      ref: branch,
    },
    base: {
      ref: 'master',
    },
    repository: {
      name: repository,
      owner: {
        login: username,
      },
    },
    state: 'merged',
    merged: true,
  };
});

afterEach(() => {
  nock.cleanAll();
});

describe.each(supportedApiVersions)('API %s - Webhook endpoint', (version) => {
  it('sends a notification when staticman pull request is merged', async () => {
    basePrBody.parameters.version = version.charAt(1);

    const mockPrResponse = {
      ...basePrResponse,
      body: `<!--staticman_notification:${JSON.stringify(basePrBody)}-->`,
    };

    const mockConfigContents = sampleData.config1.replace('master', basePrBody.parameters.branch);

    const mockConfigInfo = {
      ...basePrBody.parameters,
      contents: mockConfigContents,
    };

    const pullScope = GitHubMocks.fetchPullRequest(mockPrResponse);
    const configScope = GitHubMocks.fetchConfigFile(mockConfigInfo);
    const deleteScope = GitHubMocks.deleteBranch(basePrBody.parameters);

    expect.assertions(3);

    await request(staticman)
      .post(`/${version}/webhook`)
      .set('X-GitHub-Delivery', 'id')
      .set('X-GitHub-Event', 'pull_request')
      .send({
        repository: {
          owner: {
            login: 'johndoe',
          },
          name: 'foobar',
        },
        number: 1,
      })
      .expect(200);

    expect(pullScope.isDone()).toBe(true);
    expect(configScope.isDone()).toBe(true);
    expect(deleteScope.isDone()).toBe(true);
  });

  it('ignores pull requests not generated by staticman', async () => {
    const mockPrResponse = {
      ...basePrResponse,
      head: {
        ref: 'some-other-branch',
      },
    };

    const pullScope = GitHubMocks.fetchPullRequest(mockPrResponse);

    expect.assertions(1);

    await request(staticman)
      .post(`/${version}/webhook`)
      .set('X-GitHub-Delivery', 'id')
      .set('X-GitHub-Event', 'pull_request')
      .send({
        repository: {
          owner: {
            login: 'johndoe',
          },
          name: 'foobar',
        },
        number: 1,
      })
      .expect(200);

    expect(pullScope.isDone()).toBe(true);
  });

  it('ignores staticman pull requests which have not yet been merged', async () => {
    const mockPrResponse = {
      ...basePrResponse,
      state: 'open',
      merged: false,
    };

    const pullScope = GitHubMocks.fetchPullRequest(mockPrResponse);

    expect.assertions(1);

    await request(staticman)
      .post(`/${version}/webhook`)
      .set('X-GitHub-Delivery', 'id')
      .set('X-GitHub-Event', 'pull_request')
      .send({
        repository: {
          owner: {
            login: 'johndoe',
          },
          name: 'foobar',
        },
        number: 1,
      })
      .expect(200);

    expect(pullScope.isDone()).toBe(true);
  });

  it('ignores non-pull request events', async () => {
    await request(staticman)
      .post(`/${version}/webhook`)
      .set('X-GitHub-Delivery', 'id')
      .set('X-GitHub-Event', 'deployment')
      .send({})
      .expect(200);
  });
});
